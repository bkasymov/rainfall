https://www.youtube.com/watch?v=Q5rUgkXrzyQ&ab_channel=KonturAcademy
Когда мы выводим больше модификаторов, чем передаём по буферу, то печатает дальше уже то, что содержится в стеке
Соответственно, если мы напишем %х без передачи аргумента, то он будет показывать нам адреса того, что находится в стеке.
А %n записывает в адреса переменных, которые передаются аргументов, сколько символов было распечатано через printf.
Если получать строку от пользователя и не проверять на модификаторы, то тем самым можно воспользоваться уязвимостями printf по выводу
всего, что есть в стэке.

Память printf
arg1
arg2
arg3
[padding]?
[padding]
[padding]
EBP? 
Обычно ebp / rbp содержит адрес вершины текущего кадра стека, поэтому иногда на локальные переменные ссылаются как на смещение относительно ebp, а не как смещение до esp. Фрейм стека - это, по сути, просто пространство, используемое в стеке данной функцией.
EBP is the 32-bit register for the base pointer, which is the address of the current activation frame on
the stack (more on this below).
return

print <- уже вызыв сист функ принта

https://www.youtube.com/watch?v=kZBt15ineJ8&list=PLU-TUGRFxOHjDoi8FNb5l0jc7b1nhk_X5&ab_channel=KonturAcademy

Память делится на несколько частей

Высшие адреса:
1. Аргументы и переменные окружения
2. стэк - локальные переменные
Нижние адреса
3. куча - замолоченная память
4. BSS - указатели
5. Data - инициализированные глоб перемен
6. Code

стэк и куча входят в стековый фрейм пользователя

data содержит инициализированные глобальные статические данные
bss содержит неинициализированные глобальные данные.
 что насчет локальных и динамических переменных? Они сгруппированы в область памяти, зарезервированную для выполнения программы (стековый фрейм пользователя).
Указатели хранятся в бсс

int main()
{
char * name[] = {"/bin/sh", NULL};
execve(name[0], name, NULL);
return (0);
}

Среди множества функций, при помощи которых можно вызвать оболочку, много причин за то, чтобы использовать execve(). Во-первых, это настоящий системный вызов, в отличие от других функций из семейства exec(), которые по сути являются функциями библиотеки GlibC основанными на execve(). Системный вызов происходит при помощи прерывания. Достаточно определить регистры и их значения, чтобы получить эффективный и короткий ассемблерный код.
Кроме того, если execve() успешно выполнена, вызывающая программа (в нашем случае основное приложение) замещается выполняемым кодом новой программы и данный код запускается. Если вызов execve() оказался неуспешным, выполнение программы продолжается.
Статья про уязвимость ret2libc, про котороую говорит топчик в github.
https://codeby.net/threads/perepolnenie-bufera-i-texnika-ehkspluatacii-ret2libc-razrabotka-ehksplojtov-chast-7.67567/
